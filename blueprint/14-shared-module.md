# Shared Module Blueprint

## Overview
The Shared Module provides common types, utilities, constants, and helper functions used across the entire Clear AI v2 system. It prevents code duplication, circular dependencies, and ensures consistency.

## Purpose

### Why Shared Module?
1. **Single Source of Truth** - Types defined once, used everywhere
2. **No Circular Dependencies** - Agents can import from shared without depending on each other
3. **DRY Principle** - Utilities written once, reused everywhere
4. **Type Safety** - Consistent interfaces across the system
5. **Easy Maintenance** - Update types in one place

## Structure

```
src/shared/
├── types/
│   ├── index.ts          # Re-exports all types
│   ├── agent.ts          # Agent-related types
│   ├── tool.ts           # Tool-related types
│   ├── memory.ts         # Memory-related types
│   ├── llm.ts            # LLM-related types
│   └── common.ts         # Common/generic types
├── utils/
│   ├── index.ts          # Re-exports all utilities
│   ├── date.ts           # Date/time utilities
│   ├── validation.ts     # Validation helpers
│   ├── formatting.ts     # String/data formatting
│   ├── retry.ts          # Retry logic utilities
│   └── errors.ts         # Error utilities
├── constants/
│   ├── index.ts          # Re-exports all constants
│   ├── config.ts         # Configuration constants
│   ├── messages.ts       # Error/success messages
│   └── defaults.ts       # Default values
└── index.ts              # Main barrel export
```

## Type Definitions

### Agent Types

```typescript
// src/shared/types/agent.ts

/**
 * Plan generated by Planner Agent
 */
export interface Plan {
  steps: PlanStep[];
  metadata?: PlanMetadata;
}

export interface PlanStep {
  tool: string;
  params: Record<string, any>;
  depends_on?: number[];
  parallel?: boolean;
}

export interface PlanMetadata {
  query: string;
  timestamp: string;
  estimated_duration_ms?: number;
}

/**
 * Tool execution result from Executor Agent
 */
export interface ToolResult {
  success: boolean;
  tool: string;
  data?: any;
  error?: ErrorDetails;
  metadata: ToolResultMetadata;
}

export interface ToolResultMetadata {
  tool: string;
  executionTime: number;
  timestamp: string;
  retries?: number;
}

export interface ErrorDetails {
  code: string;
  message: string;
  details?: any;
}

/**
 * Analysis from Analyzer Agent
 */
export interface Analysis {
  summary: string;
  insights: Insight[];
  entities: Entity[];
  anomalies: Anomaly[];
  metadata: AnalysisMetadata;
}

export interface Insight {
  type: 'trend' | 'pattern' | 'correlation' | 'comparison';
  description: string;
  confidence: number; // 0-1
  supporting_data: any[];
}

export interface Entity {
  id: string;
  type: string;
  name: string;
  attributes: Record<string, any>;
  relationships?: Relationship[];
}

export interface Relationship {
  type: string;
  target_entity_id: string;
  strength?: number;
}

export interface Anomaly {
  type: 'outlier' | 'unexpected' | 'missing' | 'threshold_exceeded';
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  affected_entities: string[];
  data: any;
}

export interface AnalysisMetadata {
  tool_results_count: number;
  successful_results?: number;
  failed_results?: number;
  analysis_time_ms: number;
}

/**
 * Final response from Summarizer Agent
 */
export interface FinalResponse {
  message: string;
  tools_used: string[];
  data?: any;
  analysis?: Analysis;
  metadata: ResponseMetadata;
}

export interface ResponseMetadata {
  request_id: string;
  total_duration_ms: number;
  timestamp: string;
  error?: boolean;
}
```

### Tool Types

```typescript
// src/shared/types/tool.ts

/**
 * MCP Tool interface
 */
export interface MCPTool {
  name: string;
  description: string;
  schema: ToolSchema;
  execute(params: Record<string, any>): Promise<ToolResult>;
}

export interface ToolSchema {
  params: Record<string, ToolParam>;
  returns: {
    type: string;
    description: string;
  };
}

export interface ToolParam {
  type: string;
  description: string;
  required: boolean;
  default?: any;
  enum?: string[];
}

/**
 * Domain-specific types (Waste Management)
 */
export interface Shipment {
  id: string;
  facility_id: string;
  date: string;
  status: ShipmentStatus;
  weight_kg: number;
  has_contaminants: boolean;
  origin?: string;
  destination?: string;
}

export type ShipmentStatus = 'pending' | 'in_transit' | 'delivered' | 'rejected';

export interface Facility {
  id: string;
  name: string;
  location: string;
  type: FacilityType;
  capacity_tons: number;
  current_load_tons?: number;
  coordinates?: Coordinates;
}

export type FacilityType = 'sorting' | 'processing' | 'disposal';

export interface Coordinates {
  lat: number;
  lon: number;
}

export interface Contaminant {
  id: string;
  shipment_id: string;
  facility_id?: string;
  type: string;
  concentration_ppm: number;
  risk_level: RiskLevel;
  detected_at: string;
  notes?: string;
}

export type RiskLevel = 'low' | 'medium' | 'high' | 'critical';

export interface Inspection {
  id: string;
  shipment_id: string;
  facility_id: string;
  date: string;
  status: InspectionStatus;
  inspector: string;
  notes?: string;
  contaminants_detected?: string[];
  risk_assessment?: string;
}

export type InspectionStatus = 'accepted' | 'rejected' | 'pending';
```

### Memory Types

```typescript
// src/shared/types/memory.ts

/**
 * Episodic Memory (Neo4j)
 */
export interface EpisodicEvent {
  id: string;
  type: EventType;
  timestamp: string;
  data: any;
  relationships?: EventRelationships;
}

export type EventType = 'request' | 'tool_call' | 'insight' | 'error';

export interface EventRelationships {
  caused_by?: string[];
  led_to?: string[];
  relates_to?: string[];
}

export interface EpisodicQuery {
  type?: string;
  date_from?: string;
  date_to?: string;
  entity_ids?: string[];
  relationship_type?: string;
  limit?: number;
}

/**
 * Semantic Memory (Pinecone)
 */
export interface SemanticRecord {
  id: string;
  text: string;
  embedding: number[];
  metadata: SemanticMetadata;
}

export interface SemanticMetadata {
  type: 'summary' | 'insight' | 'entity' | 'query';
  timestamp: string;
  source?: string;
  entities?: string[];
  [key: string]: any;
}

export interface SemanticQuery {
  query: string;
  top_k?: number;
  filter?: Record<string, any>;
  namespace?: string;
}

export interface SemanticResult {
  id: string;
  score: number;
  text: string;
  metadata: any;
}
```

### LLM Types

```typescript
// src/shared/types/llm.ts

export type LLMProvider = 'openai' | 'anthropic' | 'ollama';

export interface LLMConfig {
  provider: LLMProvider;
  model: string;
  api_key?: string;
  base_url?: string;
  temperature?: number;
  max_tokens?: number;
  top_p?: number;
}

export interface LLMRequest {
  messages: LLMMessage[];
  config?: Partial<LLMConfig>;
  system_prompt?: string;
}

export interface LLMMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface LLMResponse {
  content: string;
  provider: LLMProvider;
  model: string;
  usage?: TokenUsage;
  metadata: LLMMetadata;
}

export interface TokenUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

export interface LLMMetadata {
  latency_ms: number;
  retries: number;
}

export interface LLMProviderAdapter {
  name: LLMProvider;
  isAvailable(): Promise<boolean>;
  generate(request: LLMRequest): Promise<LLMResponse>;
}
```

### Common Types

```typescript
// src/shared/types/common.ts

/**
 * Generic result type for operations
 */
export interface Result<T, E = Error> {
  success: boolean;
  data?: T;
  error?: E;
}

/**
 * Pagination
 */
export interface PaginationParams {
  page: number;
  limit: number;
  offset?: number;
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    has_more: boolean;
  };
}

/**
 * Date range
 */
export interface DateRange {
  date_from: string;
  date_to: string;
}

/**
 * Key-value metadata
 */
export type Metadata = Record<string, any>;

/**
 * Configuration
 */
export interface SystemConfig {
  server: ServerConfig;
  tools: ToolsConfig;
  llm: LLMSystemConfig;
  memory: MemorySystemConfig;
  agents: AgentsConfig;
  features: FeaturesConfig;
}

export interface ServerConfig {
  name: string;
  version: string;
  port?: number;
  env: 'development' | 'production' | 'test';
}

export interface ToolsConfig {
  api_base_url: string;
  timeout: number;
  retries: number;
  retry_delay: number;
}

export interface LLMSystemConfig {
  primary: LLMConfig;
  fallbacks: LLMConfig[];
}

export interface MemorySystemConfig {
  neo4j: Neo4jConfig;
  pinecone: PineconeConfig;
}

export interface Neo4jConfig {
  uri: string;
  user: string;
  password: string;
}

export interface PineconeConfig {
  api_key: string;
  environment: string;
  index_name: string;
}

export interface AgentsConfig {
  planner: PlannerConfig;
  executor: ExecutorConfig;
  analyzer: AnalyzerConfig;
  summarizer: SummarizerConfig;
  orchestrator: OrchestratorConfig;
}

export interface PlannerConfig {
  temperature: number;
  max_retries: number;
  validate_tool_availability: boolean;
}

export interface ExecutorConfig {
  max_parallel_executions: number;
  tool_timeout: number;
  max_retries: number;
  retry_delay: number;
  fail_fast: boolean;
}

export interface AnalyzerConfig {
  anomaly_threshold: number;
  min_confidence: number;
  use_llm: boolean;
  enable_statistical_analysis: boolean;
}

export interface SummarizerConfig {
  max_length: number;
  format: 'plain' | 'markdown' | 'json';
  include_details: boolean;
  include_recommendations: boolean;
  tone: 'professional' | 'casual' | 'technical';
}

export interface OrchestratorConfig {
  enable_memory: boolean;
  max_retries: number;
  timeout: number;
  enable_context_loading: boolean;
}

export interface FeaturesConfig {
  enable_memory: boolean;
  enable_context_loading: boolean;
  max_parallel_executions: number;
}
```

### Index File (Re-exports)

```typescript
// src/shared/types/index.ts
export * from './agent.js';
export * from './tool.js';
export * from './memory.js';
export * from './llm.js';
export * from './common.js';
```

## Utility Functions

### Date Utilities

```typescript
// src/shared/utils/date.ts

/**
 * Format date to ISO string (YYYY-MM-DD)
 */
export function formatDate(date: Date): string {
  return date.toISOString().split('T')[0];
}

/**
 * Parse temporal reference to date range
 */
export function parseTemporalReference(reference: string): DateRange {
  const today = new Date();
  
  switch (reference.toLowerCase()) {
    case 'today':
      return {
        date_from: formatDate(today),
        date_to: formatDate(today)
      };
      
    case 'yesterday':
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      return {
        date_from: formatDate(yesterday),
        date_to: formatDate(yesterday)
      };
      
    case 'last week':
      const lastWeek = new Date(today);
      lastWeek.setDate(lastWeek.getDate() - 7);
      return {
        date_from: formatDate(lastWeek),
        date_to: formatDate(today)
      };
      
    case 'this week':
      const monday = new Date(today);
      monday.setDate(monday.getDate() - monday.getDay() + 1);
      return {
        date_from: formatDate(monday),
        date_to: formatDate(today)
      };
      
    case 'this month':
      const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
      return {
        date_from: formatDate(firstDay),
        date_to: formatDate(today)
      };
      
    case 'last month':
      const lastMonth = new Date(today);
      lastMonth.setMonth(lastMonth.getMonth() - 1);
      const firstDayLastMonth = new Date(lastMonth.getFullYear(), lastMonth.getMonth(), 1);
      const lastDayLastMonth = new Date(lastMonth.getFullYear(), lastMonth.getMonth() + 1, 0);
      return {
        date_from: formatDate(firstDayLastMonth),
        date_to: formatDate(lastDayLastMonth)
      };
      
    default:
      throw new Error(`Unknown temporal reference: ${reference}`);
  }
}

/**
 * Get date N days ago
 */
export function getDaysAgo(days: number): Date {
  const date = new Date();
  date.setDate(date.getDate() - days);
  return date;
}

/**
 * Check if date is within range
 */
export function isDateInRange(date: string, range: DateRange): boolean {
  return date >= range.date_from && date <= range.date_to;
}

/**
 * Get current timestamp (ISO format)
 */
export function getCurrentTimestamp(): string {
  return new Date().toISOString();
}
```

### Validation Utilities

```typescript
// src/shared/utils/validation.ts
import { z } from 'zod';

/**
 * Validate against Zod schema
 */
export function validate<T>(schema: z.ZodSchema<T>, data: unknown): T {
  return schema.parse(data);
}

/**
 * Safe validation (returns result object)
 */
export function safeValidate<T>(
  schema: z.ZodSchema<T>,
  data: unknown
): { success: true; data: T } | { success: false; error: z.ZodError } {
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, error: result.error };
}

/**
 * Validate email
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * Validate URL
 */
export function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * Validate ISO date string
 */
export function isValidISODate(date: string): boolean {
  const isoDateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!isoDateRegex.test(date)) return false;
  
  const d = new Date(date);
  return d instanceof Date && !isNaN(d.getTime());
}

/**
 * Validate UUID
 */
export function isValidUUID(uuid: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}
```

### Formatting Utilities

```typescript
// src/shared/utils/formatting.ts

/**
 * Format number with commas
 */
export function formatNumber(num: number): string {
  return num.toLocaleString();
}

/**
 * Format percentage
 */
export function formatPercentage(value: number, decimals: number = 1): string {
  return `${(value * 100).toFixed(decimals)}%`;
}

/**
 * Format duration (ms to human readable)
 */
export function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
  if (ms < 3600000) return `${(ms / 60000).toFixed(1)}m`;
  return `${(ms / 3600000).toFixed(1)}h`;
}

/**
 * Truncate string
 */
export function truncate(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str;
  return str.slice(0, maxLength - 3) + '...';
}

/**
 * Capitalize first letter
 */
export function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

/**
 * Convert to title case
 */
export function toTitleCase(str: string): string {
  return str
    .split(' ')
    .map(word => capitalize(word))
    .join(' ');
}

/**
 * Format bytes to human readable
 */
export function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
}

/**
 * Pretty print JSON
 */
export function prettyJSON(obj: any): string {
  return JSON.stringify(obj, null, 2);
}
```

### Retry Utilities

```typescript
// src/shared/utils/retry.ts

export interface RetryOptions {
  maxRetries: number;
  baseDelay: number;
  maxDelay?: number;
  exponential?: boolean;
  onRetry?: (attempt: number, error: Error) => void;
}

/**
 * Retry operation with exponential backoff
 */
export async function withRetry<T>(
  operation: () => Promise<T>,
  options: Partial<RetryOptions> = {}
): Promise<T> {
  const {
    maxRetries = 3,
    baseDelay = 1000,
    maxDelay = 10000,
    exponential = true,
    onRetry
  } = options;
  
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error: any) {
      lastError = error;
      
      if (onRetry) {
        onRetry(attempt, error);
      }
      
      if (attempt < maxRetries) {
        const delay = exponential
          ? Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay)
          : baseDelay;
        
        await sleep(delay);
      }
    }
  }
  
  throw lastError || new Error('Max retries exceeded');
}

/**
 * Sleep utility
 */
export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Timeout wrapper
 */
export async function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  errorMessage: string = 'Operation timed out'
): Promise<T> {
  return Promise.race([
    promise,
    sleep(timeoutMs).then(() => {
      throw new Error(errorMessage);
    })
  ]);
}
```

### Error Utilities

```typescript
// src/shared/utils/errors.ts

/**
 * Base error class
 */
export class ClearAIError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ClearAIError';
    Error.captureStackTrace(this, this.constructor);
  }
  
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      details: this.details
    };
  }
}

/**
 * Specific error types
 */
export class ToolExecutionError extends ClearAIError {
  constructor(tool: string, message: string, details?: any) {
    super(`Tool execution failed: ${tool}`, 'TOOL_EXECUTION_ERROR', {
      tool,
      ...details
    });
    this.name = 'ToolExecutionError';
  }
}

export class PlanGenerationError extends ClearAIError {
  constructor(message: string, details?: any) {
    super(message, 'PLAN_GENERATION_ERROR', details);
    this.name = 'PlanGenerationError';
  }
}

export class LLMProviderError extends ClearAIError {
  constructor(provider: string, message: string, details?: any) {
    super(`LLM provider error: ${provider}`, 'LLM_PROVIDER_ERROR', {
      provider,
      ...details
    });
    this.name = 'LLMProviderError';
  }
}

export class MemoryError extends ClearAIError {
  constructor(operation: string, message: string, details?: any) {
    super(`Memory operation failed: ${operation}`, 'MEMORY_ERROR', {
      operation,
      ...details
    });
    this.name = 'MemoryError';
  }
}

export class ValidationError extends ClearAIError {
  constructor(message: string, details?: any) {
    super(message, 'VALIDATION_ERROR', details);
    this.name = 'ValidationError';
  }
}

/**
 * Error handler wrapper
 */
export function wrapError(error: unknown): ClearAIError {
  if (error instanceof ClearAIError) {
    return error;
  }
  
  if (error instanceof Error) {
    return new ClearAIError(error.message, 'UNKNOWN_ERROR', {
      originalError: error.name
    });
  }
  
  return new ClearAIError(
    'An unknown error occurred',
    'UNKNOWN_ERROR',
    { error }
  );
}
```

### Index File (Re-exports)

```typescript
// src/shared/utils/index.ts
export * from './date.js';
export * from './validation.js';
export * from './formatting.js';
export * from './retry.js';
export * from './errors.js';
```

## Constants

```typescript
// src/shared/constants/config.ts

export const DEFAULT_TIMEOUT = 30000; // 30 seconds
export const DEFAULT_RETRIES = 3;
export const DEFAULT_RETRY_DELAY = 1000;
export const DEFAULT_PAGE_SIZE = 100;
export const MAX_PARALLEL_EXECUTIONS = 5;

// LLM
export const DEFAULT_TEMPERATURE = 0.7;
export const DEFAULT_MAX_TOKENS = 1000;
export const PLANNING_TEMPERATURE = 0.1; // Lower for deterministic plans
export const SUMMARIZING_TEMPERATURE = 0.7;

// Memory
export const DEFAULT_SEMANTIC_TOP_K = 5;
export const DEFAULT_EPISODIC_LIMIT = 10;

// Analysis
export const DEFAULT_ANOMALY_THRESHOLD = 2.0; // Standard deviations
export const DEFAULT_MIN_CONFIDENCE = 0.7;

// src/shared/constants/messages.ts

export const ERROR_MESSAGES = {
  TOOL_NOT_FOUND: (tool: string) => `Tool not found: ${tool}`,
  PLAN_INVALID: 'Generated plan is invalid',
  NO_RESULTS: 'No results found',
  ALL_PROVIDERS_FAILED: 'All LLM providers failed',
  MEMORY_UNAVAILABLE: 'Memory system unavailable',
  TIMEOUT: (operation: string) => `${operation} timed out`,
  MAX_RETRIES: (operation: string) => `${operation} failed after maximum retries`,
};

export const SUCCESS_MESSAGES = {
  PLAN_GENERATED: 'Plan generated successfully',
  EXECUTION_COMPLETE: 'Execution completed successfully',
  ANALYSIS_COMPLETE: 'Analysis completed successfully',
  MEMORY_STORED: 'Data stored in memory',
};

// src/shared/constants/defaults.ts

export const DEFAULT_CONFIG = {
  server: {
    port: 3000,
    env: 'development' as const
  },
  tools: {
    timeout: DEFAULT_TIMEOUT,
    retries: DEFAULT_RETRIES,
    retry_delay: DEFAULT_RETRY_DELAY
  },
  agents: {
    planner: {
      temperature: PLANNING_TEMPERATURE,
      max_retries: DEFAULT_RETRIES
    },
    executor: {
      max_parallel_executions: MAX_PARALLEL_EXECUTIONS,
      tool_timeout: DEFAULT_TIMEOUT,
      fail_fast: false
    },
    analyzer: {
      anomaly_threshold: DEFAULT_ANOMALY_THRESHOLD,
      min_confidence: DEFAULT_MIN_CONFIDENCE,
      use_llm: true
    }
  }
};

// src/shared/constants/index.ts
export * from './config.js';
export * from './messages.js';
export * from './defaults.js';
```

## Main Export

```typescript
// src/shared/index.ts

// Types
export * from './types/index.js';

// Utilities
export * from './utils/index.js';

// Constants
export * from './constants/index.js';
```

## Usage Examples

### Importing Types

```typescript
// Other modules can import from shared
import {
  Plan,
  ToolResult,
  Analysis,
  FinalResponse,
  MCPTool,
  LLMProvider
} from '../shared/types/index.js';

// Or use barrel export
import {
  Plan,
  ToolResult,
  formatDate,
  withRetry,
  DEFAULT_TIMEOUT
} from '../shared/index.js';
```

### Using Utilities

```typescript
import { parseTemporalReference, formatDuration, withRetry } from '../shared/utils/index.js';

// Parse temporal references
const dateRange = parseTemporalReference('last week');
console.log(dateRange); // { date_from: '2025-10-04', date_to: '2025-10-11' }

// Format duration
const duration = formatDuration(1500); // "1.5s"

// Retry with exponential backoff
const result = await withRetry(
  () => fetchData(),
  {
    maxRetries: 3,
    baseDelay: 1000,
    onRetry: (attempt, error) => {
      console.log(`Retry attempt ${attempt}:`, error.message);
    }
  }
);
```

### Using Constants

```typescript
import { DEFAULT_TIMEOUT, ERROR_MESSAGES } from '../shared/constants/index.js';

// Use constants
const timeout = process.env.TIMEOUT || DEFAULT_TIMEOUT;

// Use error messages
throw new Error(ERROR_MESSAGES.TOOL_NOT_FOUND('shipments'));
```

### Custom Errors

```typescript
import { ToolExecutionError, wrapError } from '../shared/utils/errors.js';

try {
  // ... operation
} catch (error) {
  throw new ToolExecutionError('shipments', 'Failed to fetch data', {
    statusCode: 500
  });
}

// Or wrap unknown errors
try {
  // ... operation
} catch (error) {
  throw wrapError(error);
}
```

## Benefits

### 1. No Circular Dependencies
```typescript
// ✅ Good: Both agents import from shared
// planner.ts
import { Plan } from '../shared/types/index.js';

// executor.ts  
import { Plan, ToolResult } from '../shared/types/index.js';

// ❌ Bad: Circular dependency
// planner.ts imports from executor.ts
// executor.ts imports from planner.ts
```

### 2. Single Source of Truth
```typescript
// Types defined once in shared/types/agent.ts
// Used by all agents without duplication
```

### 3. Consistent Behavior
```typescript
// All modules use same date parsing
import { parseTemporalReference } from '../shared/utils/date.js';

// All modules use same retry logic
import { withRetry } from '../shared/utils/retry.js';
```

### 4. Easy Testing
```typescript
// Test utilities once, use everywhere
import { formatDate } from '../shared/utils/date.js';

describe('formatDate', () => {
  it('should format date correctly', () => {
    expect(formatDate(new Date('2025-10-11'))).toBe('2025-10-11');
  });
});
```

## Testing Strategy

```typescript
// src/tests/shared/utils/date.test.ts
import {
  formatDate,
  parseTemporalReference,
  isDateInRange
} from '../../../shared/utils/date.js';

describe('Date Utilities', () => {
  describe('parseTemporalReference', () => {
    it('should parse "last week"', () => {
      const result = parseTemporalReference('last week');
      expect(result.date_from).toBeDefined();
      expect(result.date_to).toBeDefined();
    });
    
    it('should parse "this month"', () => {
      const result = parseTemporalReference('this month');
      expect(result.date_from.endsWith('-01')).toBe(true);
    });
    
    it('should throw on invalid reference', () => {
      expect(() => parseTemporalReference('invalid')).toThrow();
    });
  });
});
```

## Next Steps

1. Create `src/shared/` directory structure
2. Implement types first (most important)
3. Implement utilities
4. Add constants
5. Update existing code to use shared module
6. Write tests for all utilities
7. Document any new utilities added during development

