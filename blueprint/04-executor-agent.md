# Executor Agent Blueprint

## Overview
The Executor Agent is responsible for executing plans generated by the Planner Agent. It manages tool invocation, handles parallelization, resolves dependencies between steps, and aggregates results.

## Responsibilities

1. **Plan Execution**
   - Execute plan steps in correct order
   - Respect dependencies between steps
   - Handle sequential and parallel execution
   - Track execution progress

2. **Tool Invocation**
   - Call MCP tools with parameters
   - Resolve parameter templates from previous results
   - Handle tool errors gracefully
   - Track tool execution metadata

3. **Result Aggregation**
   - Collect results from all tool executions
   - Maintain execution order information
   - Preserve metadata (timing, errors, retries)
   - Format results for analysis

4. **Error Management**
   - Retry failed tool calls
   - Handle partial failures
   - Provide detailed error information
   - Implement fallback strategies

## Architecture

```typescript
// src/agents/executor.ts
import { Plan, PlanStep, ToolResult } from './types.js';
import { MCPServer } from '../mcp/server.js';

export interface ExecutorConfig {
  maxParallelExecutions: number;
  toolTimeout: number;
  maxRetries: number;
  retryDelay: number;
  failFast: boolean; // Stop on first error
}

export class ExecutorAgent {
  private config: ExecutorConfig;
  
  constructor(
    private mcpServer: MCPServer,
    config?: Partial<ExecutorConfig>
  ) {
    this.config = {
      maxParallelExecutions: 5,
      toolTimeout: 30000,
      maxRetries: 3,
      retryDelay: 1000,
      failFast: false,
      ...config
    };
  }
  
  async execute(plan: Plan): Promise<ToolResult[]> {
    console.log(`Executing plan with ${plan.steps.length} steps`);
    
    const results: ToolResult[] = [];
    const completed = new Set<number>();
    
    // Build execution graph
    const graph = this.buildExecutionGraph(plan.steps);
    
    // Execute in topological order (respecting dependencies)
    while (completed.size < plan.steps.length) {
      // Find steps that are ready to execute
      const readySteps = this.findReadySteps(plan.steps, completed, graph);
      
      if (readySteps.length === 0) {
        throw new Error('Circular dependency or invalid plan');
      }
      
      console.log(`Executing ${readySteps.length} steps in parallel`);
      
      // Execute ready steps in parallel (up to maxParallelExecutions)
      const batchResults = await this.executeBatch(
        readySteps,
        plan.steps,
        results
      );
      
      // Store results and mark as completed
      for (let i = 0; i < readySteps.length; i++) {
        const stepIndex = readySteps[i];
        results[stepIndex] = batchResults[i];
        completed.add(stepIndex);
        
        // Check for failure if failFast is enabled
        if (this.config.failFast && !batchResults[i].success) {
          throw new Error(
            `Step ${stepIndex} failed: ${batchResults[i].error?.message}`
          );
        }
      }
    }
    
    console.log(`Plan execution complete. ${results.length} results`);
    return results;
  }
  
  private buildExecutionGraph(steps: PlanStep[]): Map<number, number[]> {
    const graph = new Map<number, number[]>();
    
    for (let i = 0; i < steps.length; i++) {
      const deps = steps[i].depends_on || [];
      graph.set(i, deps);
    }
    
    // Validate: no circular dependencies
    this.detectCircularDependencies(graph);
    
    return graph;
  }
  
  private detectCircularDependencies(graph: Map<number, number[]>): void {
    const visited = new Set<number>();
    const recursionStack = new Set<number>();
    
    const hasCycle = (node: number): boolean => {
      visited.add(node);
      recursionStack.add(node);
      
      const deps = graph.get(node) || [];
      for (const dep of deps) {
        if (!visited.has(dep)) {
          if (hasCycle(dep)) return true;
        } else if (recursionStack.has(dep)) {
          return true;
        }
      }
      
      recursionStack.delete(node);
      return false;
    };
    
    for (const node of graph.keys()) {
      if (!visited.has(node)) {
        if (hasCycle(node)) {
          throw new Error('Circular dependency detected in plan');
        }
      }
    }
  }
  
  private findReadySteps(
    steps: PlanStep[],
    completed: Set<number>,
    graph: Map<number, number[]>
  ): number[] {
    const ready: number[] = [];
    
    for (let i = 0; i < steps.length; i++) {
      if (completed.has(i)) continue;
      
      const deps = graph.get(i) || [];
      const allDepsComplete = deps.every(dep => completed.has(dep));
      
      if (allDepsComplete) {
        ready.push(i);
        
        // Limit parallel executions
        if (ready.length >= this.config.maxParallelExecutions) {
          break;
        }
      }
    }
    
    return ready;
  }
  
  private async executeBatch(
    stepIndices: number[],
    steps: PlanStep[],
    previousResults: ToolResult[]
  ): Promise<ToolResult[]> {
    const promises = stepIndices.map(index =>
      this.executeStep(steps[index], index, previousResults)
    );
    
    return Promise.all(promises);
  }
  
  private async executeStep(
    step: PlanStep,
    index: number,
    previousResults: ToolResult[]
  ): Promise<ToolResult> {
    console.log(`Executing step ${index}: ${step.tool}`);
    const startTime = Date.now();
    
    try {
      // Get tool from MCP server
      const tool = this.mcpServer.getTool(step.tool);
      if (!tool) {
        throw new Error(`Tool not found: ${step.tool}`);
      }
      
      // Resolve parameters (may reference previous results)
      const resolvedParams = this.resolveParameters(
        step.params,
        previousResults
      );
      
      console.log(`Resolved params for ${step.tool}:`, resolvedParams);
      
      // Execute with retries
      const result = await this.executeWithRetry(
        () => tool.execute(resolvedParams),
        step.tool
      );
      
      return result;
      
    } catch (error: any) {
      console.error(`Step ${index} (${step.tool}) failed:`, error.message);
      
      return {
        success: false,
        tool: step.tool,
        error: {
          code: 'EXECUTION_FAILED',
          message: error.message
        },
        metadata: {
          tool: step.tool,
          executionTime: Date.now() - startTime,
          timestamp: new Date().toISOString()
        }
      };
    }
  }
  
  private resolveParameters(
    params: Record<string, any>,
    previousResults: ToolResult[]
  ): Record<string, any> {
    const resolved: Record<string, any> = {};
    
    for (const [key, value] of Object.entries(params)) {
      if (typeof value === 'string' && value.includes('${step[')) {
        // Template reference: ${step[0].data.field}
        resolved[key] = this.resolveTemplate(value, previousResults);
      } else {
        resolved[key] = value;
      }
    }
    
    return resolved;
  }
  
  private resolveTemplate(
    template: string,
    previousResults: ToolResult[]
  ): any {
    // Parse template: ${step[N].data.field} or ${step[N].data.*.field}
    const match = template.match(/\$\{step\[(\d+)\]\.data((?:\.\*)?(?:\.\w+)*)\}/);
    
    if (!match) {
      return template; // Not a valid template
    }
    
    const stepIndex = parseInt(match[1]);
    const path = match[2];
    
    if (stepIndex >= previousResults.length) {
      throw new Error(`Invalid step reference: ${stepIndex}`);
    }
    
    const result = previousResults[stepIndex];
    if (!result.success || !result.data) {
      throw new Error(`Step ${stepIndex} did not produce valid data`);
    }
    
    // Navigate the path
    return this.navigatePath(result.data, path);
  }
  
  private navigatePath(data: any, path: string): any {
    if (!path || path === '') return data;
    
    const parts = path.split('.').filter(p => p !== '');
    let current = data;
    
    for (const part of parts) {
      if (part === '*') {
        // Wildcard: collect from all array elements
        if (!Array.isArray(current)) {
          throw new Error('Wildcard used on non-array');
        }
        // Return array of next path elements
        const remaining = parts.slice(parts.indexOf(part) + 1).join('.');
        return current.map(item => this.navigatePath(item, remaining));
      }
      
      if (current[part] === undefined) {
        throw new Error(`Path not found: ${path}`);
      }
      
      current = current[part];
    }
    
    return current;
  }
  
  private async executeWithRetry<T>(
    operation: () => Promise<T>,
    toolName: string
  ): Promise<T> {
    let lastError: Error | null = null;
    
    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
      try {
        // Add timeout
        const result = await Promise.race([
          operation(),
          this.timeout(this.config.toolTimeout)
        ]);
        
        return result as T;
        
      } catch (error: any) {
        lastError = error;
        console.error(
          `Tool ${toolName} attempt ${attempt}/${this.config.maxRetries} failed:`,
          error.message
        );
        
        if (attempt < this.config.maxRetries) {
          const delay = this.config.retryDelay * attempt;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError;
  }
  
  private timeout(ms: number): Promise<never> {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error(`Timeout after ${ms}ms`)), ms)
    );
  }
}
```

## Example Execution Flows

### Sequential Execution
```typescript
// Plan with dependencies
{
  steps: [
    { tool: 'shipments', params: { has_contaminants: true } },
    { 
      tool: 'contaminants-detected',
      params: { shipment_ids: '${step[0].data.*.id}' },
      depends_on: [0]
    }
  ]
}

// Execution flow:
// 1. Execute step 0 (shipments)
// 2. Resolve step[0].data.*.id to actual shipment IDs
// 3. Execute step 1 (contaminants-detected) with resolved IDs
```

### Parallel Execution
```typescript
// Plan with independent steps
{
  steps: [
    { tool: 'shipments', params: { date_from: '2025-10-01' } },
    { tool: 'facilities', params: { location: 'Hannover' } },
    { tool: 'inspections', params: { status: 'rejected' } }
  ]
}

// Execution flow:
// 1. All three steps execute in parallel (no dependencies)
// 2. Results collected simultaneously
```

### Mixed Execution
```typescript
// Plan with partial parallelization
{
  steps: [
    { tool: 'facilities', params: { location: 'Hannover' } },
    { tool: 'shipments', params: { date_from: '2025-10-01' } },
    { 
      tool: 'contaminants-detected',
      params: { facility_id: '${step[0].data[0].id}' },
      depends_on: [0]
    },
    {
      tool: 'contaminants-detected',
      params: { shipment_ids: '${step[1].data.*.id}' },
      depends_on: [1]
    }
  ]
}

// Execution flow:
// 1. Execute steps 0 and 1 in parallel
// 2. Once both complete, execute steps 2 and 3 in parallel
```

## Parameter Resolution Examples

### Simple Field Reference
```typescript
// Template: ${step[0].data.id}
// Result data: { id: 'F1', name: 'Facility' }
// Resolved: 'F1'
```

### Array Wildcard
```typescript
// Template: ${step[0].data.*.id}
// Result data: [
//   { id: 'S1', name: 'Shipment 1' },
//   { id: 'S2', name: 'Shipment 2' }
// ]
// Resolved: ['S1', 'S2']
```

### Nested Field
```typescript
// Template: ${step[0].data[0].facility.id}
// Result data: [
//   { facility: { id: 'F1', name: 'Facility' } }
// ]
// Resolved: 'F1'
```

## Testing Strategy

```typescript
// src/tests/agents/executor.test.ts
import { ExecutorAgent } from '../../agents/executor.js';
import { MCPServer } from '../../mcp/server.js';

describe('ExecutorAgent', () => {
  let executor: ExecutorAgent;
  let mockServer: any;
  
  beforeEach(() => {
    mockServer = {
      getTool: jest.fn()
    };
    
    executor = new ExecutorAgent(mockServer);
  });
  
  it('should execute simple plan', async () => {
    const mockTool = {
      execute: jest.fn().mockResolvedValue({
        success: true,
        data: [{ id: 'S1' }],
        metadata: {
          tool: 'shipments',
          executionTime: 100,
          timestamp: new Date().toISOString()
        }
      })
    };
    
    mockServer.getTool.mockReturnValue(mockTool);
    
    const plan = {
      steps: [
        { tool: 'shipments', params: { limit: 10 } }
      ]
    };
    
    const results = await executor.execute(plan);
    
    expect(results).toHaveLength(1);
    expect(results[0].success).toBe(true);
    expect(mockTool.execute).toHaveBeenCalledWith({ limit: 10 });
  });
  
  it('should execute steps with dependencies in order', async () => {
    const executionOrder: string[] = [];
    
    const tool1 = {
      execute: jest.fn().mockImplementation(async () => {
        executionOrder.push('tool1');
        return {
          success: true,
          data: [{ id: 'S1' }],
          metadata: { tool: 'shipments', executionTime: 0, timestamp: '' }
        };
      })
    };
    
    const tool2 = {
      execute: jest.fn().mockImplementation(async () => {
        executionOrder.push('tool2');
        return {
          success: true,
          data: [],
          metadata: { tool: 'contaminants', executionTime: 0, timestamp: '' }
        };
      })
    };
    
    mockServer.getTool
      .mockReturnValueOnce(tool1)
      .mockReturnValueOnce(tool2);
    
    const plan = {
      steps: [
        { tool: 'shipments', params: {} },
        { 
          tool: 'contaminants',
          params: { ids: '${step[0].data.*.id}' },
          depends_on: [0]
        }
      ]
    };
    
    await executor.execute(plan);
    
    expect(executionOrder).toEqual(['tool1', 'tool2']);
  });
  
  it('should resolve parameter templates', async () => {
    const tool1 = {
      execute: jest.fn().mockResolvedValue({
        success: true,
        data: [{ id: 'S1' }, { id: 'S2' }],
        metadata: { tool: 'shipments', executionTime: 0, timestamp: '' }
      })
    };
    
    const tool2 = {
      execute: jest.fn().mockResolvedValue({
        success: true,
        data: [],
        metadata: { tool: 'contaminants', executionTime: 0, timestamp: '' }
      })
    };
    
    mockServer.getTool
      .mockReturnValueOnce(tool1)
      .mockReturnValueOnce(tool2);
    
    const plan = {
      steps: [
        { tool: 'shipments', params: {} },
        {
          tool: 'contaminants',
          params: { shipment_ids: '${step[0].data.*.id}' },
          depends_on: [0]
        }
      ]
    };
    
    await executor.execute(plan);
    
    expect(tool2.execute).toHaveBeenCalledWith({
      shipment_ids: ['S1', 'S2']
    });
  });
  
  it('should handle tool failures gracefully', async () => {
    const tool1 = {
      execute: jest.fn().mockRejectedValue(new Error('Tool failed'))
    };
    
    mockServer.getTool.mockReturnValue(tool1);
    
    const plan = {
      steps: [{ tool: 'shipments', params: {} }]
    };
    
    const results = await executor.execute(plan);
    
    expect(results[0].success).toBe(false);
    expect(results[0].error?.message).toContain('Tool failed');
  });
  
  it('should detect circular dependencies', async () => {
    const plan = {
      steps: [
        { tool: 'tool1', params: {}, depends_on: [1] },
        { tool: 'tool2', params: {}, depends_on: [0] }
      ]
    };
    
    await expect(executor.execute(plan)).rejects.toThrow(
      'Circular dependency'
    );
  });
  
  it('should execute independent steps in parallel', async () => {
    const delays: number[] = [];
    
    const createTool = (delay: number) => ({
      execute: jest.fn().mockImplementation(async () => {
        delays.push(delay);
        await new Promise(resolve => setTimeout(resolve, delay));
        return {
          success: true,
          data: [],
          metadata: { tool: 'test', executionTime: delay, timestamp: '' }
        };
      })
    });
    
    mockServer.getTool
      .mockReturnValueOnce(createTool(100))
      .mockReturnValueOnce(createTool(100))
      .mockReturnValueOnce(createTool(100));
    
    const plan = {
      steps: [
        { tool: 'tool1', params: {} },
        { tool: 'tool2', params: {} },
        { tool: 'tool3', params: {} }
      ]
    };
    
    const startTime = Date.now();
    await executor.execute(plan);
    const duration = Date.now() - startTime;
    
    // Should take ~100ms (parallel) not ~300ms (sequential)
    expect(duration).toBeLessThan(200);
  });
});
```

## Performance Monitoring

```typescript
export class ExecutorAgent {
  private metrics = {
    totalExecutions: 0,
    successfulExecutions: 0,
    failedExecutions: 0,
    avgExecutionTime: 0,
    toolMetrics: new Map<string, {
      calls: number;
      failures: number;
      avgTime: number;
    }>()
  };
  
  private trackToolExecution(
    toolName: string,
    duration: number,
    success: boolean
  ): void {
    if (!this.metrics.toolMetrics.has(toolName)) {
      this.metrics.toolMetrics.set(toolName, {
        calls: 0,
        failures: 0,
        avgTime: 0
      });
    }
    
    const metrics = this.metrics.toolMetrics.get(toolName)!;
    metrics.calls++;
    if (!success) metrics.failures++;
    metrics.avgTime = 
      (metrics.avgTime * (metrics.calls - 1) + duration) / metrics.calls;
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      toolMetrics: Object.fromEntries(this.metrics.toolMetrics)
    };
  }
}
```

## Next Steps

1. Implement basic sequential execution
2. Add dependency resolution
3. Add parallel execution
4. Add parameter template resolution
5. Add retry logic
6. Add performance monitoring
7. Add execution visualization/logging

