# Type System Blueprint

## Overview
Complete TypeScript type definitions for the Clear AI v2 system. All interfaces are strictly typed for maximum type safety.

## Core Agent Types

```typescript
// src/agents/types.ts

// Plan structure generated by Planner agent
export interface Plan {
  steps: PlanStep[];
  metadata?: {
    query: string;
    timestamp: string;
    estimated_duration_ms?: number;
  };
}

export interface PlanStep {
  tool: string;
  params: Record<string, any>;
  depends_on?: number[]; // Indices of steps this depends on
  parallel?: boolean;    // Can be run in parallel
}

// Tool execution result from Executor agent
export interface ToolResult {
  success: boolean;
  tool: string;
  data?: any;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  metadata: {
    executionTime: number;
    timestamp: string;
    retries?: number;
  };
}

// Analysis output from Analyzer agent
export interface Analysis {
  summary: string;
  insights: Insight[];
  entities: Entity[];
  anomalies: Anomaly[];
  metadata: {
    tool_results_count: number;
    analysis_time_ms: number;
  };
}

export interface Insight {
  type: 'trend' | 'pattern' | 'correlation' | 'comparison';
  description: string;
  confidence: number; // 0-1
  supporting_data: any[];
}

export interface Entity {
  id: string;
  type: string;
  name: string;
  attributes: Record<string, any>;
  relationships?: Relationship[];
}

export interface Relationship {
  type: string;
  target_entity_id: string;
  strength?: number;
}

export interface Anomaly {
  type: 'outlier' | 'unexpected' | 'missing' | 'threshold_exceeded';
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  affected_entities: string[];
  data: any;
}

// Final response from Summarizer agent
export interface FinalResponse {
  message: string;
  tools_used: string[];
  data?: any;
  analysis?: Analysis;
  metadata: {
    request_id: string;
    total_duration_ms: number;
    timestamp: string;
  };
}
```

## Memory Types

```typescript
// src/memory/types.ts

// Episodic memory (Neo4j)
export interface EpisodicEvent {
  id: string;
  type: 'request' | 'tool_call' | 'insight' | 'error';
  timestamp: string;
  data: any;
  relationships: {
    caused_by?: string[];
    led_to?: string[];
    relates_to?: string[];
  };
}

export interface EpisodicQuery {
  event_type?: string;
  date_from?: string;
  date_to?: string;
  entity_ids?: string[];
  relationship_type?: string;
  limit?: number;
}

// Semantic memory (Pinecone)
export interface SemanticRecord {
  id: string;
  text: string;
  embedding: number[];
  metadata: {
    type: 'summary' | 'insight' | 'entity' | 'query';
    timestamp: string;
    source?: string;
    entities?: string[];
  };
}

export interface SemanticQuery {
  query: string;
  top_k?: number;
  filter?: Record<string, any>;
  namespace?: string;
}

export interface SemanticResult {
  id: string;
  score: number;
  text: string;
  metadata: any;
}
```

## LLM Provider Types

```typescript
// src/llm/types.ts

export type LLMProvider = 'openai' | 'anthropic' | 'ollama';

export interface LLMConfig {
  provider: LLMProvider;
  model: string;
  api_key?: string;
  base_url?: string;
  temperature?: number;
  max_tokens?: number;
  top_p?: number;
}

export interface LLMRequest {
  messages: LLMMessage[];
  config?: Partial<LLMConfig>;
  system_prompt?: string;
}

export interface LLMMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface LLMResponse {
  content: string;
  provider: LLMProvider;
  model: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
  metadata: {
    latency_ms: number;
    retries: number;
  };
}

export interface LLMProviderAdapter {
  name: LLMProvider;
  isAvailable(): Promise<boolean>;
  generate(request: LLMRequest): Promise<LLMResponse>;
}
```

## Configuration Types

```typescript
// src/config/types.ts

export interface SystemConfig {
  server: {
    name: string;
    version: string;
    port?: number;
  };
  
  tools: {
    api_base_url: string;
    timeout: number;
    retries: number;
    retry_delay: number;
  };
  
  llm: {
    primary: LLMConfig;
    fallbacks: LLMConfig[];
  };
  
  memory: {
    neo4j: {
      uri: string;
      user: string;
      password: string;
    };
    pinecone: {
      api_key: string;
      environment: string;
      index_name: string;
    };
  };
  
  agents: {
    planner: {
      temperature: number;
      max_retries: number;
    };
    executor: {
      parallel_limit: number;
      timeout: number;
    };
    analyzer: {
      anomaly_threshold: number;
      min_confidence: number;
    };
    summarizer: {
      max_length: number;
      format: 'plain' | 'markdown' | 'json';
    };
  };
}
```

## Validation Schemas (Zod)

```typescript
// src/validation/schemas.ts
import { z } from 'zod';

export const PlanSchema = z.object({
  steps: z.array(
    z.object({
      tool: z.string(),
      params: z.record(z.any()),
      depends_on: z.array(z.number()).optional(),
      parallel: z.boolean().optional(),
    })
  ),
  metadata: z.object({
    query: z.string(),
    timestamp: z.string(),
    estimated_duration_ms: z.number().optional(),
  }).optional(),
});

export const ToolResultSchema = z.object({
  success: z.boolean(),
  tool: z.string(),
  data: z.any().optional(),
  error: z.object({
    code: z.string(),
    message: z.string(),
    details: z.any().optional(),
  }).optional(),
  metadata: z.object({
    executionTime: z.number(),
    timestamp: z.string(),
    retries: z.number().optional(),
  }),
});

export const AnalysisSchema = z.object({
  summary: z.string(),
  insights: z.array(z.object({
    type: z.enum(['trend', 'pattern', 'correlation', 'comparison']),
    description: z.string(),
    confidence: z.number().min(0).max(1),
    supporting_data: z.array(z.any()),
  })),
  entities: z.array(z.any()),
  anomalies: z.array(z.any()),
  metadata: z.object({
    tool_results_count: z.number(),
    analysis_time_ms: z.number(),
  }),
});

export const FinalResponseSchema = z.object({
  message: z.string(),
  tools_used: z.array(z.string()),
  data: z.any().optional(),
  analysis: AnalysisSchema.optional(),
  metadata: z.object({
    request_id: z.string(),
    total_duration_ms: z.number(),
    timestamp: z.string(),
  }),
});
```

## Error Types

```typescript
// src/errors/types.ts

export class ClearAIError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ClearAIError';
  }
}

export class ToolExecutionError extends ClearAIError {
  constructor(tool: string, message: string, details?: any) {
    super(`Tool execution failed: ${tool}`, 'TOOL_EXECUTION_ERROR', {
      tool,
      ...details,
    });
    this.name = 'ToolExecutionError';
  }
}

export class PlanGenerationError extends ClearAIError {
  constructor(message: string, details?: any) {
    super(message, 'PLAN_GENERATION_ERROR', details);
    this.name = 'PlanGenerationError';
  }
}

export class LLMProviderError extends ClearAIError {
  constructor(provider: string, message: string, details?: any) {
    super(`LLM provider error: ${provider}`, 'LLM_PROVIDER_ERROR', {
      provider,
      ...details,
    });
    this.name = 'LLMProviderError';
  }
}

export class MemoryError extends ClearAIError {
  constructor(operation: string, message: string, details?: any) {
    super(`Memory operation failed: ${operation}`, 'MEMORY_ERROR', {
      operation,
      ...details,
    });
    this.name = 'MemoryError';
  }
}
```

## Usage Examples

### Type-Safe Plan Creation

```typescript
import { Plan, PlanSchema } from './agents/types';

const plan: Plan = {
  steps: [
    {
      tool: 'shipments',
      params: { date_from: '2025-10-04', has_contaminants: true },
      parallel: true,
    },
    {
      tool: 'contaminants-detected',
      params: { shipment_ids: ['${step[0].results}'] },
      depends_on: [0],
    },
  ],
  metadata: {
    query: 'Get contaminated shipments last week',
    timestamp: new Date().toISOString(),
  },
};

// Validate at runtime
const validated = PlanSchema.parse(plan);
```

### Type-Safe Response Building

```typescript
import { FinalResponse } from './agents/types';

const response: FinalResponse = {
  message: 'Found 3 contaminated shipments with high lead levels',
  tools_used: ['shipments', 'contaminants-detected'],
  data: {
    shipments: [...],
    contaminants: [...],
  },
  metadata: {
    request_id: 'req_12345',
    total_duration_ms: 1250,
    timestamp: new Date().toISOString(),
  },
};
```

## Next Steps

1. Implement all type definitions in respective files
2. Add Zod validation for runtime type checking
3. Use types consistently across all modules
4. Generate TypeDoc documentation
5. Export types for external use

