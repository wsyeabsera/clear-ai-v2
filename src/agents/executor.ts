/**
 * Executor Agent
 * Executes plans generated by Planner Agent with dependency resolution and parallel execution
 */

import { Plan, PlanStep, ToolResult } from '../shared/types/agent.js';
import { MCPServer } from '../mcp/server.js';

export interface ExecutorConfig {
  maxParallelExecutions: number;
  toolTimeout: number;
  maxRetries: number;
  retryDelay: number;
  failFast: boolean; // Stop on first error
}

export class ExecutorAgent {
  private config: ExecutorConfig;

  constructor(
    private mcpServer: MCPServer,
    config?: Partial<ExecutorConfig>
  ) {
    this.config = {
      maxParallelExecutions: 5,
      toolTimeout: 30000,
      maxRetries: 3,
      retryDelay: 1000,
      failFast: false,
      ...config,
    };
  }

  async execute(
    plan: Plan,
    progressCallback?: (stepIndex: number, total: number, stepName: string) => void
  ): Promise<ToolResult[]> {
    console.log(`⚡ [Executor] Executing plan with ${plan.steps.length} steps`);

    const results: ToolResult[] = [];
    const completed = new Set<number>();

    // Build execution graph
    const graph = this.buildExecutionGraph(plan.steps);

    // Execute in topological order (respecting dependencies)
    while (completed.size < plan.steps.length) {
      // Find steps that are ready to execute
      const readySteps = this.findReadySteps(plan.steps, completed, graph);

      if (readySteps.length === 0) {
        throw new Error('Circular dependency or invalid plan');
      }

      console.log(`⚡ [Executor] Executing ${readySteps.length} steps in parallel`);

      // Emit progress for each ready step
      for (const stepIndex of readySteps) {
        if (stepIndex !== undefined) {
          const step = plan.steps[stepIndex];
          if (step) {
            console.log(`🔧 [Executor] Step ${stepIndex + 1}/${plan.steps.length}: ${step.tool}`);
            progressCallback?.(stepIndex + 1, plan.steps.length, step.tool);
          }
        }
      }

      // Execute ready steps in parallel (up to maxParallelExecutions)
      const batchResults = await this.executeBatch(
        readySteps,
        plan.steps,
        results
      );

      // Store results and mark as completed
      for (let i = 0; i < readySteps.length; i++) {
        const stepIndex = readySteps[i];
        if (stepIndex !== undefined) {
          results[stepIndex] = batchResults[i]!;
          completed.add(stepIndex);

          const result = batchResults[i];
          if (result) {
            const status = result.success ? '✅' : '❌';
            console.log(`${status} [Executor] Step ${stepIndex + 1} complete: ${result.success ? 'success' : 'failed'}`);
          }

          // Check for failure if failFast is enabled
          if (result && this.config.failFast && !result.success) {
            throw new Error(
              `Step ${stepIndex} failed: ${result.error?.message}`
            );
          }
        }
      }
    }

    console.log(`✅ [Executor] Plan execution complete. ${results.length} results`);
    return results;
  }

  private buildExecutionGraph(steps: PlanStep[]): Map<number, number[]> {
    const graph = new Map<number, number[]>();

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      if (step) {
        const deps = step.depends_on || [];
        graph.set(i, deps);
      }
    }

    // Validate: no circular dependencies
    this.detectCircularDependencies(graph);

    return graph;
  }

  private detectCircularDependencies(graph: Map<number, number[]>): void {
    const visited = new Set<number>();
    const recursionStack = new Set<number>();

    const hasCycle = (node: number): boolean => {
      visited.add(node);
      recursionStack.add(node);

      const deps = graph.get(node) || [];
      for (const dep of deps) {
        if (!visited.has(dep)) {
          if (hasCycle(dep)) return true;
        } else if (recursionStack.has(dep)) {
          return true;
        }
      }

      recursionStack.delete(node);
      return false;
    };

    for (const node of graph.keys()) {
      if (!visited.has(node)) {
        if (hasCycle(node)) {
          throw new Error('Circular dependency detected in plan');
        }
      }
    }
  }

  private findReadySteps(
    steps: PlanStep[],
    completed: Set<number>,
    graph: Map<number, number[]>
  ): number[] {
    const ready: number[] = [];

    for (let i = 0; i < steps.length; i++) {
      if (completed.has(i)) continue;

      const deps = graph.get(i) || [];
      const allDepsComplete = deps.every(dep => completed.has(dep));

      if (allDepsComplete) {
        ready.push(i);

        // Limit parallel executions
        if (ready.length >= this.config.maxParallelExecutions) {
          break;
        }
      }
    }

    return ready;
  }

  private async executeBatch(
    stepIndices: number[],
    steps: PlanStep[],
    previousResults: ToolResult[]
  ): Promise<ToolResult[]> {
    const promises = stepIndices.map(index => {
      const step = steps[index];
      if (!step) {
        throw new Error(`Step at index ${index} not found`);
      }
      return this.executeStep(step, index, previousResults);
    });

    return Promise.all(promises);
  }

  private async executeStep(
    step: PlanStep,
    index: number,
    previousResults: ToolResult[]
  ): Promise<ToolResult> {
    console.log(`[ExecutorAgent] Executing step ${index}: ${step.tool}`);
    const startTime = Date.now();

    try {
      // Get tool from MCP server
      const tool = this.mcpServer.getTool(step.tool);
      if (!tool) {
        throw new Error(`Tool not found: ${step.tool}`);
      }

      // Resolve parameters (may reference previous results)
      const resolvedParams = this.resolveParameters(
        step.params,
        previousResults
      );

      console.log(`[ExecutorAgent] Resolved params for ${step.tool}:`, resolvedParams);

      // Execute with retries
      const result = await this.executeWithRetry(
        () => tool.execute(resolvedParams),
        step.tool
      );

      return result;

    } catch (error: any) {
      console.error(`[ExecutorAgent] Step ${index} (${step.tool}) failed:`, error.message);

      return {
        success: false,
        tool: step.tool,
        error: {
          code: 'EXECUTION_FAILED',
          message: error.message,
        },
        metadata: {
          executionTime: Date.now() - startTime,
          timestamp: new Date().toISOString(),
        },
      };
    }
  }

  private resolveParameters(
    params: Record<string, any>,
    previousResults: ToolResult[]
  ): Record<string, any> {
    const resolved: Record<string, any> = {};

    for (const [key, value] of Object.entries(params)) {
      if (typeof value === 'string' && value.includes('${step[')) {
        // Template reference: ${step[0].data.field}
        resolved[key] = this.resolveTemplate(value, previousResults);
      } else {
        resolved[key] = value;
      }
    }

    return resolved;
  }

  private resolveTemplate(
    template: string,
    previousResults: ToolResult[]
  ): any {
    // Parse template: ${step[N].data.field} or ${step[N].data.*.field} or ${step[N].data[0].field}
    const match = template.match(/\$\{step\[(\d+)\]\.data(.+?)\}/);

    if (!match || !match[1] || !match[2]) {
      return template; // Not a valid template
    }

    const stepIndex = parseInt(match[1]);
    const path = match[2];

    if (stepIndex >= previousResults.length) {
      throw new Error(`Invalid step reference: ${stepIndex}`);
    }

    const result = previousResults[stepIndex];
    if (!result || !result.success || !result.data) {
      throw new Error(`Step ${stepIndex} did not produce valid data`);
    }

    // Navigate the path
    return this.navigatePath(result.data, path);
  }

  private navigatePath(data: any, path: string): any {
    if (!path || path === '') return data;

    // Parse path into tokens: .field, [index], .*
    const tokens: Array<{ type: 'field' | 'index' | 'wildcard'; value: string | number }> = [];
    
    // Match .field, [index], or .*
    const tokenRegex = /\.([a-zA-Z_][a-zA-Z0-9_]*|\*)|(\[(\d+)\])/g;
    let match;
    
    while ((match = tokenRegex.exec(path)) !== null) {
      if (match[1] !== undefined) {
        // .field or .*
        if (match[1] === '*') {
          tokens.push({ type: 'wildcard', value: '*' });
        } else {
          tokens.push({ type: 'field', value: match[1] });
        }
      } else if (match[3] !== undefined) {
        // [index]
        tokens.push({ type: 'index', value: parseInt(match[3]) });
      }
    }

    let current = data;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (!token) continue;

      if (token.type === 'wildcard') {
        // Wildcard: collect from all array elements
        if (!Array.isArray(current)) {
          throw new Error('Wildcard used on non-array');
        }
        
        // Get remaining tokens
        const remainingTokens = tokens.slice(i + 1);
        if (remainingTokens.length === 0) {
          return current;
        }
        
        // Apply remaining path to each element
        return current.map(item => {
          let result = item;
          for (const t of remainingTokens) {
            if (!t) continue;
            if (t.type === 'field') {
              result = result?.[t.value as string];
            } else if (t.type === 'index') {
              result = result?.[t.value as number];
            }
          }
          return result;
        });
      } else if (token.type === 'field') {
        if (current[token.value as string] === undefined) {
          throw new Error(`Path not found: ${path} at ${token.value}`);
        }
        current = current[token.value as string];
      } else if (token.type === 'index') {
        if (!Array.isArray(current)) {
          throw new Error(`Trying to index non-array with [${token.value}]`);
        }
        current = current[token.value as number];
      }
    }

    return current;
  }

  private async executeWithRetry<T>(
    operation: () => Promise<T>,
    toolName: string
  ): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
      try {
        // Add timeout
        const result = await Promise.race([
          operation(),
          this.timeout(this.config.toolTimeout),
        ]);

        return result as T;

      } catch (error: any) {
        lastError = error;
        console.error(
          `[ExecutorAgent] Tool ${toolName} attempt ${attempt}/${this.config.maxRetries} failed:`,
          error.message
        );

        if (attempt < this.config.maxRetries) {
          const delay = this.config.retryDelay * attempt;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }

  private timeout(ms: number): Promise<never> {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error(`Timeout after ${ms}ms`)), ms)
    );
  }
}

