/**
 * Executor Agent
 * Executes plans generated by Planner Agent with dependency resolution and parallel execution
 */

import { Plan, PlanStep, ToolResult } from '../shared/types/agent.js';
import { ToolRegistry } from '../shared/tool-registry.js';
import { StepResultCache } from './executor/step-cache.js';
import { StepReferenceResolver } from './executor/reference-resolver.js';

export interface ExecutorConfig {
  maxParallelExecutions: number;
  toolTimeout: number;
  maxRetries: number;
  retryDelay: number;
  failFast: boolean; // Stop on first error
  enableAggressiveParallelization: boolean; // Enhanced parallel execution
  stepTimeout: number; // Per-step timeout
}

export class ExecutorAgent {
  private config: ExecutorConfig;
  private stepCache: StepResultCache;
  private referenceResolver: StepReferenceResolver;
  private enableStepReferences: boolean;

  constructor(
    private toolRegistry: ToolRegistry,
    config?: Partial<ExecutorConfig>
  ) {
    this.config = {
      maxParallelExecutions: 5,
      toolTimeout: 30000,
      maxRetries: 3,
      retryDelay: 1000,
      failFast: false,
      enableAggressiveParallelization: process.env.ENABLE_AGGRESSIVE_PARALLELIZATION === 'true',
      stepTimeout: parseInt(process.env.STEP_TIMEOUT_MS || '15000'),
      ...config,
    };
    
    // Initialize step reference resolution components
    this.stepCache = new StepResultCache();
    this.referenceResolver = new StepReferenceResolver();
    this.enableStepReferences = process.env.ENABLE_STEP_REFERENCES === 'true';
    
    if (this.enableStepReferences) {
      console.log('[ExecutorAgent] Step reference resolution enabled');
    }

    if (this.config.enableAggressiveParallelization) {
      console.log('[ExecutorAgent] Aggressive parallelization enabled');
    }
  }

  async execute(
    plan: Plan,
    progressCallback?: (stepIndex: number, total: number, stepName: string) => void
  ): Promise<ToolResult[]> {
    console.log(`⚡ [Executor] Executing plan with ${plan.steps.length} steps`);

    // Clear cache for new execution
    this.stepCache.clear();
    
    const results: ToolResult[] = [];
    const completed = new Set<number>();

    // Build execution graph
    const graph = this.buildExecutionGraph(plan.steps);

    // Optimize execution order if aggressive parallelization is enabled
    const optimizedSteps = this.config.enableAggressiveParallelization
      ? this.optimizeDependencyGraph(plan.steps, graph)
      : plan.steps;

    // Execute in topological order (respecting dependencies)
    while (completed.size < optimizedSteps.length) {
      // Find steps that are ready to execute
      const readySteps = this.findReadySteps(optimizedSteps, completed, graph);

      if (readySteps.length === 0) {
        throw new Error('Circular dependency or invalid plan');
      }

      // Enhanced parallel execution with better batching
      const parallelBatches = this.config.enableAggressiveParallelization
        ? this.detectParallelizableSteps(readySteps, optimizedSteps)
        : [readySteps];

      for (const batch of parallelBatches) {
        console.log(`⚡ [Executor] Executing ${batch.length} steps in parallel`);

        // Emit progress for each ready step
        for (const stepIndex of batch) {
          if (stepIndex !== undefined) {
            const step = optimizedSteps[stepIndex];
            if (step) {
              console.log(`🔧 [Executor] Step ${stepIndex + 1}/${optimizedSteps.length}: ${step.tool}`);
              progressCallback?.(stepIndex + 1, optimizedSteps.length, step.tool);
            }
          }
        }

        // Execute batch with enhanced timeout handling
        const batchResults = await this.executeBatchWithTimeout(
          batch,
          optimizedSteps,
          results
        );

        // Store results and mark as completed
        for (let i = 0; i < batch.length; i++) {
          const stepIndex = batch[i];
          if (stepIndex !== undefined) {
            results[stepIndex] = batchResults[i]!;
            completed.add(stepIndex);

            const result = batchResults[i];
            if (result) {
              const status = result.success ? '✅' : '❌';
              console.log(`${status} [Executor] Step ${stepIndex + 1} complete: ${result.success ? 'success' : 'failed'}`);
            }

            // Check for failure if failFast is enabled
            if (result && this.config.failFast && !result.success) {
              throw new Error(
                `Step ${stepIndex} failed: ${result.error?.message}`
              );
            }
          }
        }
      }
    }

    console.log(`✅ [Executor] Plan execution complete. ${results.length} results`);
    return results;
  }

  private buildExecutionGraph(steps: PlanStep[]): Map<number, number[]> {
    const graph = new Map<number, number[]>();

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      if (step) {
        const deps = step.depends_on || [];
        graph.set(i, deps);
      }
    }

    // Validate: no circular dependencies
    this.detectCircularDependencies(graph);

    return graph;
  }

  private detectCircularDependencies(graph: Map<number, number[]>): void {
    const visited = new Set<number>();
    const recursionStack = new Set<number>();

    const hasCycle = (node: number): boolean => {
      visited.add(node);
      recursionStack.add(node);

      const deps = graph.get(node) || [];
      for (const dep of deps) {
        if (!visited.has(dep)) {
          if (hasCycle(dep)) return true;
        } else if (recursionStack.has(dep)) {
          return true;
        }
      }

      recursionStack.delete(node);
      return false;
    };

    for (const node of graph.keys()) {
      if (!visited.has(node)) {
        if (hasCycle(node)) {
          throw new Error('Circular dependency detected in plan');
        }
      }
    }
  }

  private findReadySteps(
    steps: PlanStep[],
    completed: Set<number>,
    graph: Map<number, number[]>
  ): number[] {
    const ready: number[] = [];

    for (let i = 0; i < steps.length; i++) {
      if (completed.has(i)) continue;

      const deps = graph.get(i) || [];
      const allDepsComplete = deps.every(dep => completed.has(dep));

      if (allDepsComplete) {
        ready.push(i);

        // Limit parallel executions
        if (ready.length >= this.config.maxParallelExecutions) {
          break;
        }
      }
    }

    return ready;
  }

  // Legacy method - kept for compatibility but not used with enhanced parallelization
  // @ts-ignore - Method kept for compatibility
  private async executeBatch(
    stepIndices: number[],
    steps: PlanStep[],
    previousResults: ToolResult[]
  ): Promise<ToolResult[]> {
    const promises = stepIndices.map(index => {
      const step = steps[index];
      if (!step) {
        throw new Error(`Step at index ${index} not found`);
      }
      return this.executeStep(step, index, previousResults);
    });

    return Promise.all(promises);
  }

  private async executeBatchWithTimeout(
    stepIndices: number[],
    steps: PlanStep[],
    previousResults: ToolResult[]
  ): Promise<ToolResult[]> {
    const promises = stepIndices.map(index => {
      const step = steps[index];
      if (!step) {
        throw new Error(`Step at index ${index} not found`);
      }
      return this.executeStepWithTimeout(step, index, previousResults);
    });

    return Promise.all(promises);
  }

  private async executeStepWithTimeout(
    step: PlanStep,
    index: number,
    previousResults: ToolResult[]
  ): Promise<ToolResult> {
    const timeout = this.config.stepTimeout;

    try {
      return await Promise.race([
        this.executeStep(step, index, previousResults),
        this.timeout(timeout)
      ]);
    } catch (error: any) {
      if (error.message.includes('Timeout after')) {
        console.error(`[ExecutorAgent] Step ${index} (${step.tool}) timed out after ${timeout}ms`);
        return {
          success: false,
          tool: step.tool,
          error: {
            code: 'TIMEOUT',
            message: `Step timed out after ${timeout}ms`,
            details: { timeout }
          },
          metadata: {
            executionTime: timeout,
            timestamp: new Date().toISOString(),
          },
          step_index: index,
          resolved_params: step.params
        };
      }
      throw error;
    }
  }

  private detectParallelizableSteps(
    readySteps: number[],
    steps: PlanStep[]
  ): number[][] {
    if (!this.config.enableAggressiveParallelization) {
      return [readySteps];
    }

    // Group steps by tool type for better parallelization
    const toolGroups = new Map<string, number[]>();

    for (const stepIndex of readySteps) {
      const step = steps[stepIndex];
      if (step) {
        const toolType = this.getToolType(step.tool);
        if (!toolGroups.has(toolType)) {
          toolGroups.set(toolType, []);
        }
        toolGroups.get(toolType)!.push(stepIndex);
      }
    }

    // Create batches prioritizing independent tools
    const batches: number[][] = [];
    const independentTools = ['list', 'get', 'analytics'];

    // First batch: independent tools that can run together
    const independentBatch: number[] = [];
    for (const [toolType, indices] of toolGroups) {
      if (independentTools.some(t => toolType.includes(t))) {
        independentBatch.push(...indices);
      }
    }
    
    if (independentBatch.length > 0) {
      batches.push(independentBatch);
    }

    // Remaining batches: other tools
    for (const [toolType, indices] of toolGroups) {
      if (!independentTools.some(t => toolType.includes(t))) {
        batches.push(indices);
      }
    }

    return batches.length > 0 ? batches : [readySteps];
  }

  private getToolType(toolName: string): string {
    if (toolName.includes('_list')) return 'list';
    if (toolName.includes('_get')) return 'get';
    if (toolName.includes('_create')) return 'create';
    if (toolName.includes('_update')) return 'update';
    if (toolName.includes('_delete')) return 'delete';
    if (toolName.includes('analytics')) return 'analytics';
    return 'other';
  }

  private optimizeDependencyGraph(
    steps: PlanStep[],
    graph: Map<number, number[]>
  ): PlanStep[] {
    if (!this.config.enableAggressiveParallelization) {
      return steps;
    }

    // Reorder steps to maximize parallel execution opportunities
    const optimized: PlanStep[] = [];
    const visited = new Set<number>();
    const inProgress = new Set<number>();

    const visit = (index: number) => {
      if (inProgress.has(index)) {
        throw new Error('Circular dependency detected');
      }
      if (visited.has(index)) {
        return;
      }

      inProgress.add(index);

      // Visit dependencies first
      const deps = graph.get(index) || [];
      for (const dep of deps) {
        visit(dep);
      }

      inProgress.delete(index);
      visited.add(index);
      optimized.push(steps[index]!);
    };

    // Visit all steps
    for (let i = 0; i < steps.length; i++) {
      visit(i);
    }

    return optimized;
  }

  private async executeStep(
    step: PlanStep,
    index: number,
    previousResults: ToolResult[]
  ): Promise<ToolResult> {
    console.log(`[ExecutorAgent] Executing step ${index}: ${step.tool}`);
    const startTime = Date.now();

    try {
      // Get tool from registry
      const tool = this.toolRegistry.getToolInstance(step.tool);
      if (!tool) {
        throw new Error(`Tool not found: ${step.tool}`);
      }


      // Validate parameters against schema
      const schema = this.toolRegistry.getToolSchema(step.tool);
      if (schema) {
        const validation = this.toolRegistry.validateParameters(step.tool, step.params || {});
        if (!validation.valid) {
          throw new Error(`Invalid parameters for ${step.tool}: ${validation.errors.join(', ')}`);
        }
      }

      // Resolve parameters using enhanced resolution if enabled
      let resolvedParams: Record<string, any>;
      if (this.enableStepReferences) {
        const resolutionResult = this.referenceResolver.resolveReferences(
          step.params || {},  // Ensure params is at least an empty object
          this.stepCache
        );
        
        if (!resolutionResult.success) {
          throw new Error(`Parameter resolution failed: ${resolutionResult.error}`);
        }
        
        resolvedParams = resolutionResult.resolved || {};  // Ensure result is not undefined
        console.log(`[ExecutorAgent] Enhanced resolution for ${step.tool}:`, resolvedParams);
      } else {
        // Fallback to original resolution method
        resolvedParams = this.resolveParameters(step.params || {}, previousResults);
        console.log(`[ExecutorAgent] Legacy resolution for ${step.tool}:`, resolvedParams);
      }

      // Validate resolved params
      if (resolvedParams === undefined || resolvedParams === null) {
        console.warn(`[ExecutorAgent] Warning: resolvedParams is ${resolvedParams}, using empty object`);
        resolvedParams = {};
      }


      // Execute with retries
      const result = await this.executeWithRetry(
        () => tool.execute(resolvedParams),
        step.tool
      );

      // Enhanced result with step tracking
      const enhancedResult: ToolResult = {
        ...result,
        step_index: index,
        resolved_params: resolvedParams
      };

      // Cache result for future reference resolution
      if (this.enableStepReferences) {
        this.stepCache.set(index, {
          success: result.success,
          data: result.data,
          error: result.error?.message || undefined,
          timestamp: new Date(),
          tool: step.tool,
          params: resolvedParams
        });
      }

      return enhancedResult;

    } catch (error: any) {
      console.error(`[ExecutorAgent] Step ${index} (${step.tool}) failed:`, error.message);

      // Log additional details if available
      if (error.response) {
        console.error(`  HTTP Status: ${error.response.status}`);
        console.error(`  Response:`, error.response.data);
      }
      if (error.config?.url) {
        console.error(`  URL: ${error.config.url}`);
      }

      const errorResult: ToolResult = {
        success: false,
        tool: step.tool,
        error: {
          code: 'EXECUTION_FAILED',
          message: error.message,
          details: {
            httpStatus: error.response?.status,
            url: error.config?.url,
            apiError: error.response?.data,
          }
        },
        metadata: {
          executionTime: Date.now() - startTime,
          timestamp: new Date().toISOString(),
        },
        step_index: index,
        resolved_params: step.params
      };

      // Cache failed result for reference resolution
      if (this.enableStepReferences) {
        this.stepCache.set(index, {
          success: false,
          data: null,
          error: error.message,
          timestamp: new Date(),
          tool: step.tool,
          params: step.params
        });
      }

      return errorResult;
    }
  }

  private resolveParameters(
    params: Record<string, any>,
    previousResults: ToolResult[]
  ): Record<string, any> {
    const resolved: Record<string, any> = {};

    for (const [key, value] of Object.entries(params)) {
      if (typeof value === 'string' && value.includes('${step[')) {
        // Template reference: ${step[0].data.field}
        resolved[key] = this.resolveTemplate(value, previousResults);
      } else {
        resolved[key] = value;
      }
    }

    return resolved;
  }

  private resolveTemplate(
    template: string,
    previousResults: ToolResult[]
  ): any {
    // Parse template: ${step[N].data.field} or ${step[N].data.*.field} or ${step[N].data[0].field}
    const match = template.match(/\$\{step\[(\d+)\]\.data(.+?)\}/);

    if (!match || !match[1] || !match[2]) {
      return template; // Not a valid template
    }

    const stepIndex = parseInt(match[1]);
    const path = match[2];

    if (stepIndex >= previousResults.length) {
      throw new Error(`Invalid step reference: ${stepIndex}`);
    }

    const result = previousResults[stepIndex];
    if (!result || !result.success || !result.data) {
      throw new Error(`Step ${stepIndex} did not produce valid data`);
    }

    // Navigate the path
    return this.navigatePath(result.data, path);
  }

  private navigatePath(data: any, path: string): any {
    if (!path || path === '') return data;

    // Parse path into tokens: .field, [index], .*
    const tokens: Array<{ type: 'field' | 'index' | 'wildcard'; value: string | number }> = [];
    
    // Match .field, [index], or .*
    const tokenRegex = /\.([a-zA-Z_][a-zA-Z0-9_]*|\*)|(\[(\d+)\])/g;
    let match;
    
    while ((match = tokenRegex.exec(path)) !== null) {
      if (match[1] !== undefined) {
        // .field or .*
        if (match[1] === '*') {
          tokens.push({ type: 'wildcard', value: '*' });
        } else {
          tokens.push({ type: 'field', value: match[1] });
        }
      } else if (match[3] !== undefined) {
        // [index]
        tokens.push({ type: 'index', value: parseInt(match[3]) });
      }
    }

    let current = data;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (!token) continue;

      if (token.type === 'wildcard') {
        // Wildcard: collect from all array elements
        if (!Array.isArray(current)) {
          throw new Error('Wildcard used on non-array');
        }
        
        // Get remaining tokens
        const remainingTokens = tokens.slice(i + 1);
        if (remainingTokens.length === 0) {
          return current;
        }
        
        // Apply remaining path to each element
        return current.map(item => {
          let result = item;
          for (const t of remainingTokens) {
            if (!t) continue;
            if (t.type === 'field') {
              result = result?.[t.value as string];
            } else if (t.type === 'index') {
              result = result?.[t.value as number];
            }
          }
          return result;
        });
      } else if (token.type === 'field') {
        if (current[token.value as string] === undefined) {
          throw new Error(`Path not found: ${path} at ${token.value}`);
        }
        current = current[token.value as string];
      } else if (token.type === 'index') {
        if (!Array.isArray(current)) {
          throw new Error(`Trying to index non-array with [${token.value}]`);
        }
        current = current[token.value as number];
      }
    }

    return current;
  }

  private async executeWithRetry<T>(
    operation: () => Promise<T>,
    toolName: string
  ): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
      try {
        // Add timeout
        const result = await Promise.race([
          operation(),
          this.timeout(this.config.toolTimeout),
        ]);

        return result as T;

      } catch (error: any) {
        lastError = error;
        console.error(
          `[ExecutorAgent] Tool ${toolName} attempt ${attempt}/${this.config.maxRetries} failed:`,
          error.message
        );

        if (attempt < this.config.maxRetries) {
          const delay = this.config.retryDelay * attempt;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }

  private timeout(ms: number): Promise<never> {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error(`Timeout after ${ms}ms`)), ms)
    );
  }
}

